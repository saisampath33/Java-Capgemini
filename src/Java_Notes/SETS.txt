SET in Java
Set is an interface present in java.util.

It is a child interface of Collection.

Main goal: Store unique elements (no duplicates).

âœ… Implementing Classes of Set
1) HashSet

Uses Hash Table / HashMap internally

Fastest among sets for most operations.

2) LinkedHashSet

Same as HashSet but maintains Insertion order

Uses Hash table + doubly linked list internally.

3) TreeSet
Stores elements in sorted order

Uses Balanced BST (Red-Black Tree) internally.

âœ… Key Characteristics of Set
No Duplicate Values
Set never stores duplicates.
If duplicate is added â†’ it returns false.


Example:
HashSet<Integer> s = new HashSet<>();
s.add(10); // true
s.add(10); // false

ğŸ“Œ How it checks duplicates?

Uses: hashCode() + equals()

âœ… 2. Null Handling
âœ… HashSet

Allows only one null
Additional null â†’ duplicate â†’ not added

âœ… LinkedHashSet

Allows one null
âŒ TreeSet
âŒ Does not allow null (Java 7+)

Because sorting needs comparison â†’ null cannot be compared.

âœ… 3. Insertion Order
HashSet: âŒ Not maintained
LinkedHashSet: âœ… Maintained
TreeSet: âŒ Maintained? No (it sorts, not insertion-based)

âœ… 4. Indexing

âŒ No indexing concept in Set
So:
set.get(0) // âŒ not possible

âœ… 5. Performance

HashSet/LinkedHashSet operations are O(1) average:
add
remove
contains

TreeSet operations are O(log n)

âœ… HashSet Internal Working (Deep Explanation)
âœ… Important Point:
HashSet internally uses HashMap
HashSet set = new HashSet();

Behind the scene:
HashMap map = new HashMap();

Whenever you add element in HashSet:
set.add(x);

Internally it becomes:
map.put(x, PRESENT);

Where PRESENT is a dummy constant object.

âœ… Internal Data Structure
HashSet uses:
âœ… Array of Buckets (Nodes)
Each bucket stores:

key
hash
next (for chaining)

Example of node:
Node {
   int hash;
   Object key;
   Node next;
}

âœ… Capacity + Load Factor
âœ… Initial Capacity:
16 buckets

âœ… Load factor:
0.75

ğŸ“Œ Meaning:
When size exceeds:
16 * 0.75 = 12

Then HashSet triggers Rehashing / Resizing
âœ… new capacity = old * 2
â¡ï¸ 16 â†’ 32 â†’ 64 â†’ ...

âœ… Your Example (but more correct)
Suppose:
capacity = 16
Add 16
hash(16) % 16 = 0
Stored in bucket[0]

Add 18
hash(18) % 16 = 2
Stored in bucket[2]

Add 32
hash(32) % 16 = 0
Goes to bucket[0]
Collision occurs

âœ… Now it checks duplicates:
When you do:
hs.add(obj);
Internally it becomes:
map.put(obj, PRESENT);

Now HashMap does:

Calls obj.hashCode() â†’ to find bucket index

Calls obj.equals(existingObj) â†’ to check duplicate
Compare hash
If hash matches â†’ call equals()


If equals() returns false:
â¡ï¸ Store as next node in same bucket (LinkedList style)

âœ… Collision Handling
âœ… What is Collision?
Two different values generate same bucket index.
âœ… How HashSet solves collision?
ğŸ‘‰ By Chaining


bucket stores a linked list of nodes


Example bucket[0]:
16 â†’ 32 â†’ 48


âœ… equals() + hashCode() role
hashCode()
Finds the bucket index
equals()
Checks whether element already exists in bucket


âœ… Rule:
If two objects are equal using equals()
â¡ï¸ Their hashCode must be same.

âœ… What happens if you donâ€™t override hashCode + equals?
If you store custom objects:
class Student {
   int id;
   String name;
}

Without overriding:


duplicate objects may still be stored
because HashSet thinks they are different references.


So we must override:
âœ… hashCode()
âœ… equals()

âœ… TreeSet Internal Working (Extra points)

Uses Red-Black Tree

Stores elements in Sorted Order

Sorting happens by:
Natural ordering (Comparable)
Custom ordering (Comparator)


Example:
TreeSet<Integer> ts = new TreeSet<>();
ts.add(30);
ts.add(10);
ts.add(20);
System.out.println(ts); // [10, 20, 30]


âœ… LinkedHashSet Internal Working
It maintains insertion order by using:
âœ… Hash table + Doubly Linked List
So it stores:


Set is used when:
âœ… Uniqueness is important
âœ… fast search/remove needed


Fastest: HashSet


Ordered insertion: LinkedHashSet


Sorted output: TreeSet
